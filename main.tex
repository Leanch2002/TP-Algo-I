\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[left=2.5cm,top=3cm,right=2.5cm,bottom=3cm,bindingoffset=0.5cm]{geometry}
\usepackage{AEDLogica, AEDEspecificacion, AEDTADs}
\usepackage{caratula}


\titulo{Trabajo práctico}
\subtitulo{Especificacion de TADs}

\fecha{\today}

\materia{Algoritmos y Estructuras de Datos}
\grupo{BobElConstructorPorCopia}

\integrante{Choque, Leandro}{252/25}{leandroch2002@gmail.com}
\integrante{Musi, Santino}{965/24}{santinomusi1@gmail.com}
\integrante{Rojas, Damian}{209/25}{dam.rojas1@gmail.com}
\integrante{Martell, Juan Bautista}{622/25}{Juanbamartell@hotmail.com}
% \integrante{Apellido, Nombre2}{002/01}{email2@dominio.com} %


% Declaramos donde van a estar las figuras
% No es obligatorio, pero suele ser comodo
\graphicspath{{../static/}}

% Asi pueden escribir nuevos comandos. 
% Este por ejemplo asegura q los nombres 
% que figuren con una tipografia diferenciada  
\newcommand{\Tipo}[1]{\mathsf{#1}}
% la sintaxis es \newcommand{\nombreDeLaMacro}[cantidadDeParametros]{Lo que va ser remplazado por el macro} 
\newcommand{\norm}[1]{\vert #1\vert}

% Empieza el documento
\begin{document}

\maketitle

\section{Supongo que acá iría una descripción}

Breve descripción.

Luego veremos bien el formato, esto de momento es para tener un esqueleto.

\section{Especificacion}

% Acá arrancamos el TAD --------------------------------------------------
\begin{tad}{EdR}

% SECCIÓN DE DUDAS/COMENTARIOS --------------------------------------------------

% Preguntar si estudiantes necesita nombre o identificación
% Preguntar por \yLuego
% Preguntar por igualdad(), si basta con '=' en arrays

% RENOMBRE DE TIPOS --------------------------------------------------

% Aula: Seq[Seq[Examen]] - Doble secuencia para representar
% Cordenada: Struct{f:Z, c:Z}
% Examen: seq[Paso]
% Paso : Seq[Respuesta]
% Respuesta: Char
% ALumno : Struct{examen:Examen, coord:Coordenada}


\obs{aula}{Aula}
\\
\obs{solucion}{Paso}
\\
\obs{entregas}{\seq{\tupla{Coordenadas, Paso}}}
\\
\\
% Agrego el obs entregas porque es necesario ir guardando los examenes que entregan los alumnos con el proc "entregar". La idea sería que arranca como un aula vacía. Cuando el aulmno [i][j] entrega, en el aula original ese asiento queda vacío, y en el aula de entregas, ese asiento guarda la última instancia del examen (la que tiene todas las respuestas marcadas). Así, es muy fácil al final chequear si se copió con los que tiene alrededor
% dado se copia un ejercicio que aun no 
% Metodo EdR --------------------------------------------------


\begin{proc}{EdR}
{
\In dimensionAula: \Z,
\In s: Paso,
\In cantEstudiantes: \Z
}{
\Tipo{EdR}
}
    \requiereLargo{
        (dimensionAula > 0) \yLuego
    \\ rtaValida(s) \yLuego
    \\ cantValidaEstudiantes(dimensionAula, cantEstudiantes)}
    \aseguraLargo{
        (\norm{res.aula} = dimensionAula) \yLuego
    \\ aulaCuadrada(res.aula) \yLuego
    \\ noHayAlumnosJuntos(res.aula) \yLuego
    \\ (cuantosEstudiantes(res.aula) = cantEstudiantes) \yLuego
    \\ examenesSinResponder(res.aula) \yLuego
    \\ (res.solucion = s) \yLuego 
    \\ (res.entregas = \langle \rangle)
    }
\end{proc}

% True si las respuestas del paso estan en el rango de opciones
\predLargo{rtaValida}{s: Paso}{
    \paraTodo{i}{\Z}{0 \leq i < \norm{s} \implicaLuego s[i] \in \conj{"0","1","2","3","4","5","6","7","8","9"}}
}

% True si la cantidad de estudiantes a lo sumo no hace que haya alumnos juntos
\predLargo{cantValidaEstudiantes}{a: Aula, e: \Z}{
    (e \leq ifThenElse(mod(\norm{a},2)==0, \frac{\norm{a}^ 2}{2}, \frac{\norm{a} + 1}{2} * \norm{a}))    
}

\predLargo{aulaCuadrada}{a: Aula}{
    \paraTodo{i}{\Z}{0 \leq i < \norm{a} \implicaLuego \norm{a[i]} = \norm{a}}
}

\predLargo{noHayAlumnosJuntos}{a: Aula}{
    \paraTodo{i}{\Z}{0 \leq i < \norm{a} \implicaLuego 
    \\ \paraTodo{j}{\Z}{0 \leq j < \norm{a[i]}-1 \implicaLuego (a[i][j] \neq \langle \rangle \implica a[i][j+1] = \langle \rangle)}}
}

\aux{cuantosEstudiantes}{a: Aula}{\Z}
    $\sum_{i=0}^{\norm{a}-1} \sum_{j=0}^{\norm{a[i]}-1} ifThenElse(a[i][j] \neq \langle \rangle,1,0)$
\\
\predLargo{examenesSinResponder}{a: Aula}{
    \paraTodo{i}{\Z}{0 \leq i < \norm{a} \implicaLuego \paraTodo{j}{\Z}{0 \leq j < \norm{a[i]} \implicaLuego examenSinResponder(a[i][j])}}
}

% Es el complemento del pred de arriba, se fija que haya 1 paso solo de examen y que todas sus respuestas sean ""
\predLargo{examenSinResponder}{e: Examen}{
    (\norm{e} = 1 \land \paraTodo{i}{\Z}{0 \leq i < \norm{e[0]} \yLuego e[0][i] = ""})
}

% Metodo igualdad --------------------------------------------------
\begin{proc}{igualdad}
{
\In edr1,edr2: EdR,
}{
\Tipo{Bool}
}
    \requiere{True}
    \aseguraLargo{(res = True) \leftrightarrow
    \\ (edr1.aula = edr2.aula) \land
    \\ (edr1.solucion = edr2.solucion) \land
    \\ (edr1.entregas = edr2.entregas)
    }
\end{proc}

% Metodo copiarse --------------------------------------------------
\begin{proc}{copiarse}
{
\In c1, c2: Coordenada,
\Inout edr: EdR 
}{
\Tipo{}
}
    \requiereLargo{ 
        perteneceAlumno(c1, edr.aula) \yLuego
        \\ perteneceAlumno(c2, edr.aula) \yLuego
        \\ edr = edr0 \yLuego
        \\ adyacentes(c1, c2, edr.aula) \yLuego
        \\(\exists k:\Z)(ultimoPasoExamen(c1.edr.aula) = "" \land ultimoPasoExamen(c2.edr.aula) \neq "")
        %(\exists k:\Z)(edr[c1.f][c1.c][\norm{edr[c1.f][c1.c]}-1][k] = "" \land edr[c2.f][c2.c][\norm{edr[c2.f][c2.c]}-1][k] \neq "")
        } 
    \aseguraLargo{
    \norm{edr.aula[c1.f][c1.c]} = \norm{edr0.aula[c1.f][c1.c]} + 1 \yLuego
    \\ (\exists j:\Z)(ultimoPasoExamen(c1,edr0)[j] = "" \ \land \ ultimoPasoExamen(c2,edr0)[j] \neq "" \ \land \ ultimoPasoExamen(c1,edr) =
    \\ setAt(ultimoPasoExamen(c1,edr0),j,ultimoPasoExamen(c2,edr0)[j]))
    %(\exists j:\Z)((edr[c1.f][c1.c][\norm{edr[c1.f][c1.c]}-2][j] = edr[c2.f][c2.c][\norm{edr[c2.f][c1.2]}-1][j] ) \land (edr[c1.f][c1.c][\norm{edr[c1.f][c1.c]}-2][j] = "")) \yLuego
    % \paraTodo m \Z {(0 \leq m <\norm{edr[c1.f][c1.c]}  \land  m \neq j) \implicaLuego edr[\norm{a1.examen}-1][m] = edr0.Aula[a1.coord.f][a1.coord.c][\norm{a1.examen}-1][m]} \yLuego
    \\ \paraTodo {c3}{Coordenada}{(cordenadaValida(c3, edr0.Aula) \land c1.f \neq c3.f \lor c1.c \neq c3.c) \implicaLuego edr.Aula[c3.f][c3.c] = edr0.Aula[c3.f][c3.c]} \yLuego
    % el resto esta igual
    \\ edr0.solucion = edr.solucion \yLuego 
    \\ edr0.entregas = edr.entregas
    } 
\end{proc}

% las cordenadas del alumno estan en el aula y el examen es el mismo
\predLargo{perteneceAlumno}{coord:Coordenada, a:Aula}{
    (cordenadaValida(coord, edr.aula) \yLuego
    \\ \norm{a[i][j]} > 0)
}

% x e y estan entre 0 y norma del aula, por ende la cordenada es valida 
\pred{cordenadaValida}{coord:Cordenada, a:Aula}{0 \leq coord.f < \norm{a} \land 0 \leq coord.c < \norm{a}}\\

% las cordenadas estan dentro del aula y c0 esta a distancia |2| de c1 en x o esta directamente adelante en y
\predLargo{adyacentes}{coord1, coord2: Cordenada, a: Aula}{
    cordenadaValida(coord1, a) \land cordenadaValida(coord2, a) \land
    \\ ((\norm{c1.c - c0.c} = 2 \land c1.f = c0.f) \lor
    \\ (c1.c = c0.c \land  c1.f - c0.f = 1))
} 

\aux{ultimoPasoExamen}{c1:Coordenada, edr:EdR}{Examen}  \\ $ edr.aula[c1.f][c1.c][\norm{edr.aula[c1.f][c1.c]}-1]$ \\

% Metodo publicarResolucion --------------------------------------------------
\begin{proc}{consultarDarkWeb}
{
\In s: Paso,
\In posiblesAccesos: \Z,
\Inout edr: EdR
}{}
    \requiereLargo{
    rtaValida(s) \yLuego
    \\posiblesAccesos \geq 0 \yLuego}
    \asegura{res}
\end{proc}

% Metodo resolver --------------------------------------------------
\begin{proc}{resolver}
{
\In alumno: Cordenada,
\Inout edr: EdR
}{
\Tipo{Paso}
}
    \requiereLargo{
    (existeAlumno(alumno)) \yLuego
    \\(\exists i:\Z)(0 \leq i < \norm{alumno.examen[0]} \yLuego alumno.examen[\norm{alumno.examen}][k]=="")}
    \asegura{res}
\end{proc}

% Metodo entregar --------------------------------------------------
\begin{proc}{entregar}
{
\In alumno: Alumno,
\Inout edr: EdR
}{
}
    \requiereLargo{
        perteneceAlumno(alumno.Coordenada, edr.Aula) \yLuego
        \\ edr = edr0
    } 
    \aseguraLargo{
        edr.entregas = edr0.entregas ++ \tupla{alumno.coordenada, alumno.examen[\norm{alumno.examen}-1]} \land
        \\ edr.aula[alumno.coord.f][alumno.coord.c] = \langle \rangle \land
        \\ \paraTodo {c1}{Coordenada} {coordenadaValida(c1) \yLuego c1 \neq alumno.coordenada \implicaLuego edr.aula[c1.f][c1.c] = edr0.aula[c1.f][c1.c]} \yLuego
        \\ edr.solucion = edr0.solucion
        }
    

\end{proc}

% Metodo chequearCopias --------------------------------------------------
\begin{proc}{chequearCopias}
{
\In alumnos: seq<Alumno> % Creo que no recibe nada o recibe un EdR
}{
\Tipo{seq<Alumno>}
}
    \requiere{True} % Si no recibe nada va True, a lo mejor recibe un EdR pero entonces también iría True, mientras sea un EdR válido sirve
    \asegura{res} % Acá hay que ver cómo poner lo de propoción de rtas equivalentes a compañero cercano >60% y eso, cómo medirlo, o eso sería muy implementativo?
    % Quedaría tipo, para todo alumno en aula, si esSimilarACercano(aula[i][j].examen) o esSimilarAAlumnado(aula[i][j].examen) entonces se concatena a la secuencia
\end{proc}

% Metodo corregir --------------------------------------------------
\begin{proc}{corregir} 
{ %Acá dice que tenemos que corregir los examenes de los que no fueron sospechosos de copiarse, pero no podemos llamar un proc adentro de otro, o no?
\Inout edr, EdR
}{
\Tipo{seq<<Alumno, Nota>>}
}
    \requiere{True}
    \asegura{res}
\end{proc}

\end{tad}

\end{document}
